// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: members.sql

package database

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgconn"
)

const countExpiredMembers = `-- name: CountExpiredMembers :one
SELECT COUNT(*) as total_members
FROM members
WHERE created_by = $1 AND membership_end IS NOT NULL AND membership_end < NOW()
`

func (q *Queries) CountExpiredMembers(ctx context.Context, createdBy int64) (int64, error) {
	row := q.db.QueryRow(ctx, countExpiredMembers, createdBy)
	var total_members int64
	err := row.Scan(&total_members)
	return total_members, err
}

const countMembers = `-- name: CountMembers :one
SELECT COUNT(*) as total_members
FROM members
WHERE created_by = $1
`

func (q *Queries) CountMembers(ctx context.Context, createdBy int64) (int64, error) {
	row := q.db.QueryRow(ctx, countMembers, createdBy)
	var total_members int64
	err := row.Scan(&total_members)
	return total_members, err
}

const countMembersOfMemberships = `-- name: CountMembersOfMemberships :many
SELECT membership, COUNT(*) as total
FROM members
WHERE created_by = $1
GROUP BY membership
`

type CountMembersOfMembershipsRow struct {
	Membership *int64 `json:"membership"`
	Total      int64  `json:"total"`
}

func (q *Queries) CountMembersOfMemberships(ctx context.Context, createdBy int64) ([]CountMembersOfMembershipsRow, error) {
	rows, err := q.db.Query(ctx, countMembersOfMemberships, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountMembersOfMembershipsRow
	for rows.Next() {
		var i CountMembersOfMembershipsRow
		if err := rows.Scan(&i.Membership, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createMember = `-- name: CreateMember :one
INSERT INTO members (
    member_name, member_contact, membership, created_by, membership_status, membership_start, membership_end
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, member_name, member_contact, membership, created_by, membership_status, membership_start, membership_end, version
`

type CreateMemberParams struct {
	MemberName       string     `json:"member_name"`
	MemberContact    string     `json:"member_contact"`
	Membership       *int64     `json:"membership"`
	CreatedBy        int64      `json:"created_by"`
	MembershipStatus Status     `json:"membership_status"`
	MembershipStart  *time.Time `json:"membership_start"`
	MembershipEnd    *time.Time `json:"membership_end"`
}

func (q *Queries) CreateMember(ctx context.Context, arg CreateMemberParams) (Member, error) {
	row := q.db.QueryRow(ctx, createMember,
		arg.MemberName,
		arg.MemberContact,
		arg.Membership,
		arg.CreatedBy,
		arg.MembershipStatus,
		arg.MembershipStart,
		arg.MembershipEnd,
	)
	var i Member
	err := row.Scan(
		&i.ID,
		&i.MemberName,
		&i.MemberContact,
		&i.Membership,
		&i.CreatedBy,
		&i.MembershipStatus,
		&i.MembershipStart,
		&i.MembershipEnd,
		&i.Version,
	)
	return i, err
}

const deleteMember = `-- name: DeleteMember :execresult
DELETE FROM members
WHERE id = $1 AND created_by = $2
`

type DeleteMemberParams struct {
	ID        int64 `json:"id"`
	CreatedBy int64 `json:"created_by"`
}

func (q *Queries) DeleteMember(ctx context.Context, arg DeleteMemberParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, deleteMember, arg.ID, arg.CreatedBy)
}

const getExpiredMembers = `-- name: GetExpiredMembers :many
SELECT id, member_name, member_contact, membership, created_by, membership_status, membership_start, membership_end, version FROM members
WHERE created_by = $1 AND membership_end IS NOT NULL AND membership_end < NOW()
ORDER BY id
LIMIT $2 OFFSET $3
`

type GetExpiredMembersParams struct {
	CreatedBy int64 `json:"created_by"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

func (q *Queries) GetExpiredMembers(ctx context.Context, arg GetExpiredMembersParams) ([]Member, error) {
	rows, err := q.db.Query(ctx, getExpiredMembers, arg.CreatedBy, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Member
	for rows.Next() {
		var i Member
		if err := rows.Scan(
			&i.ID,
			&i.MemberName,
			&i.MemberContact,
			&i.Membership,
			&i.CreatedBy,
			&i.MembershipStatus,
			&i.MembershipStart,
			&i.MembershipEnd,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMemberByID = `-- name: GetMemberByID :one
SELECT id, member_name, member_contact, membership, created_by, membership_status, membership_start, membership_end, version FROM members
WHERE id = $1 AND created_by = $2
`

type GetMemberByIDParams struct {
	ID        int64 `json:"id"`
	CreatedBy int64 `json:"created_by"`
}

func (q *Queries) GetMemberByID(ctx context.Context, arg GetMemberByIDParams) (Member, error) {
	row := q.db.QueryRow(ctx, getMemberByID, arg.ID, arg.CreatedBy)
	var i Member
	err := row.Scan(
		&i.ID,
		&i.MemberName,
		&i.MemberContact,
		&i.Membership,
		&i.CreatedBy,
		&i.MembershipStatus,
		&i.MembershipStart,
		&i.MembershipEnd,
		&i.Version,
	)
	return i, err
}

const getMembers = `-- name: GetMembers :many
SELECT id, member_name, member_contact, membership, created_by, membership_status, membership_start, membership_end, version FROM members
WHERE created_by = $1
ORDER BY id
LIMIT $2 OFFSET $3
`

type GetMembersParams struct {
	CreatedBy int64 `json:"created_by"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

func (q *Queries) GetMembers(ctx context.Context, arg GetMembersParams) ([]Member, error) {
	rows, err := q.db.Query(ctx, getMembers, arg.CreatedBy, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Member
	for rows.Next() {
		var i Member
		if err := rows.Scan(
			&i.ID,
			&i.MemberName,
			&i.MemberContact,
			&i.Membership,
			&i.CreatedBy,
			&i.MembershipStatus,
			&i.MembershipStart,
			&i.MembershipEnd,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMember = `-- name: UpdateMember :one
UPDATE members
    set member_name = $4,
    member_contact = $5,
    membership = $6,
    membership_status = $7,
    membership_start = $8,
    membership_end = $9,
    version = version + 1
WHERE id = $1 AND created_by = $2 AND version = $3
RETURNING membership_start, membership_end
`

type UpdateMemberParams struct {
	ID               int64      `json:"id"`
	CreatedBy        int64      `json:"created_by"`
	Version          int32      `json:"version"`
	MemberName       string     `json:"member_name"`
	MemberContact    string     `json:"member_contact"`
	Membership       *int64     `json:"membership"`
	MembershipStatus Status     `json:"membership_status"`
	MembershipStart  *time.Time `json:"membership_start"`
	MembershipEnd    *time.Time `json:"membership_end"`
}

type UpdateMemberRow struct {
	MembershipStart *time.Time `json:"membership_start"`
	MembershipEnd   *time.Time `json:"membership_end"`
}

func (q *Queries) UpdateMember(ctx context.Context, arg UpdateMemberParams) (UpdateMemberRow, error) {
	row := q.db.QueryRow(ctx, updateMember,
		arg.ID,
		arg.CreatedBy,
		arg.Version,
		arg.MemberName,
		arg.MemberContact,
		arg.Membership,
		arg.MembershipStatus,
		arg.MembershipStart,
		arg.MembershipEnd,
	)
	var i UpdateMemberRow
	err := row.Scan(&i.MembershipStart, &i.MembershipEnd)
	return i, err
}
